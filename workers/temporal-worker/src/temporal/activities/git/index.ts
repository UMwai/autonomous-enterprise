/**
 * Git-related Temporal activities
 *
 * Uses GitHub CLI (gh) for repo creation and git for local operations.
 */

import { execa } from 'execa';
import { mkdir } from 'fs/promises';

/**
 * GitHub organization/user for generated projects
 */
const GITHUB_ORG = process.env.GITHUB_ORG || 'UMWai';

/**
 * Base workspace path for generated projects
 */
const WORKSPACE_BASE = process.env.WORKSPACE_DIR || '/workspaces';

export interface InitRepoInput {
  project_id: string;
  project_name: string;
  description?: string;
  private?: boolean;
}

export interface GitTagInput {
  repository_path: string;
  tag: string;
  message: string;
}

export interface PushInput {
  repository_path: string;
  remote_url: string;
}

/**
 * Initialize a new Git repository and create it on GitHub
 */
export async function initializeGitRepo(input: InitRepoInput): Promise<string> {
  const repoPath = `${WORKSPACE_BASE}/${input.project_id}`;
  const repoName = sanitizeRepoName(input.project_name);
  const fullRepoName = `${GITHUB_ORG}/${repoName}`;

  console.log(`[Git] Initializing repo at ${repoPath}`);
  console.log(`[Git] Creating GitHub repo: ${fullRepoName}`);

  // Create directory
  await mkdir(repoPath, { recursive: true });

  // Initialize git
  await execa('git', ['init', '-b', 'main'], { cwd: repoPath });

  // Configure git
  await execa('git', ['config', 'user.email', 'bot@autonomous-enterprise.ai'], { cwd: repoPath });
  await execa('git', ['config', 'user.name', 'Autonomous Enterprise Bot'], { cwd: repoPath });

  // Create README
  const readmeContent = `# ${input.project_name}

${input.description || 'An autonomous enterprise generated project.'}

---

ðŸ¤– Generated by [Autonomous Enterprise](https://github.com/UMWai/autonomous-enterprise)
`;

  await execa('sh', ['-c', `echo '${readmeContent.replace(/'/g, "\\'")}' > README.md`], { cwd: repoPath });

  // Create initial commit
  await execa('git', ['add', '-A'], { cwd: repoPath });
  await execa('git', ['commit', '-m', 'Initial commit - Autonomous Enterprise generated project'], { cwd: repoPath });

  // Create GitHub repository using gh CLI
  const repoUrl = await createGitHubRepo({
    name: repoName,
    description: input.description || `Generated product: ${input.project_name}`,
    private: input.private ?? false,
    org: GITHUB_ORG,
  });

  // Add remote and push
  await execa('git', ['remote', 'add', 'origin', repoUrl], { cwd: repoPath });

  console.log(`[Git] Repository created: ${repoUrl}`);

  return repoUrl;
}

/**
 * Create a GitHub repository using gh CLI
 */
async function createGitHubRepo(input: {
  name: string;
  description: string;
  private: boolean;
  org: string;
}): Promise<string> {
  const args = [
    'repo',
    'create',
    `${input.org}/${input.name}`,
    '--description', input.description,
    input.private ? '--private' : '--public',
    '--source', '.',
    '--push',
  ];

  try {
    // Try to create the repo
    const result = await execa('gh', args);
    console.log(`[Git] GitHub repo created: ${result.stdout}`);

    // Return the repo URL
    return `https://github.com/${input.org}/${input.name}.git`;
  } catch (error) {
    // If repo already exists, just return the URL
    if (error instanceof Error && error.message.includes('already exists')) {
      console.log(`[Git] Repo already exists, using existing: ${input.org}/${input.name}`);
      return `https://github.com/${input.org}/${input.name}.git`;
    }

    // Check if gh is authenticated
    if (error instanceof Error && error.message.includes('gh auth')) {
      console.warn('[Git] GitHub CLI not authenticated. Run: gh auth login');
    }

    throw error;
  }
}

/**
 * Create a git tag and commit
 */
export async function createGitTag(input: GitTagInput): Promise<string> {
  console.log(`[Git] Creating tag ${input.tag} at ${input.repository_path}`);

  // Stage all changes
  await execa('git', ['add', '-A'], { cwd: input.repository_path });

  // Check if there are changes to commit
  const status = await execa('git', ['status', '--porcelain'], { cwd: input.repository_path });

  if (status.stdout.trim()) {
    // Commit changes
    await execa('git', ['commit', '-m', input.message], { cwd: input.repository_path });
  } else {
    console.log('[Git] No changes to commit');
  }

  // Create tag
  await execa('git', ['tag', '-a', input.tag, '-m', input.message], { cwd: input.repository_path });

  // Get commit SHA
  const { stdout } = await execa('git', ['rev-parse', 'HEAD'], { cwd: input.repository_path });

  console.log(`[Git] Tag created: ${input.tag} at ${stdout.trim()}`);

  return stdout.trim();
}

/**
 * Push to remote repository
 */
export async function pushToRemote(input: PushInput): Promise<void> {
  console.log(`[Git] Pushing to ${input.remote_url}`);

  // Add remote if it doesn't exist
  await execa('git', ['remote', 'add', 'origin', input.remote_url], { cwd: input.repository_path }).catch(() => {
    // Remote might already exist
  });

  // Push main branch and tags
  await execa('git', ['push', '-u', 'origin', 'main', '--tags'], { cwd: input.repository_path });

  console.log('[Git] Push complete');
}

/**
 * Clone an existing repository
 */
export async function cloneRepo(input: {
  repo_url: string;
  target_path: string;
}): Promise<void> {
  console.log(`[Git] Cloning ${input.repo_url} to ${input.target_path}`);

  await execa('git', ['clone', input.repo_url, input.target_path]);

  console.log('[Git] Clone complete');
}

/**
 * Get the current commit SHA
 */
export async function getCurrentCommit(input: {
  repository_path: string;
}): Promise<string> {
  const { stdout } = await execa('git', ['rev-parse', 'HEAD'], { cwd: input.repository_path });
  return stdout.trim();
}

/**
 * Check if there are uncommitted changes
 */
export async function hasUncommittedChanges(input: {
  repository_path: string;
}): Promise<boolean> {
  const status = await execa('git', ['status', '--porcelain'], { cwd: input.repository_path });
  return status.stdout.trim().length > 0;
}

/**
 * Sanitize a project name for use as a GitHub repo name
 */
function sanitizeRepoName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 100);
}
