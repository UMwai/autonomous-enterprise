"""Living specification API endpoints."""

from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ae_api.db.models import Artifact, ArtifactType, Project
from ae_api.db.session import get_session

router = APIRouter()


class SpecDirective(BaseModel):
    """A directive in the living spec."""

    id: str
    content: str
    active: bool = True


class MissionLogEntry(BaseModel):
    """An entry in the mission log."""

    timestamp: str
    entry: str
    phase: str


class ErrorEntry(BaseModel):
    """An error in the error registry."""

    timestamp: str
    type: str
    message: str
    resolution: str | None = None


class LivingSpec(BaseModel):
    """The living specification for a project."""

    project_id: str
    version: int
    status: str

    # Directives
    directives: list[SpecDirective]

    # Tech stack
    tech_stack: dict

    # Mission state
    current_phase: str
    active_task: str | None

    # History
    mission_log: list[MissionLogEntry]
    error_registry: list[ErrorEntry]


class SpecUpdate(BaseModel):
    """Request to update spec."""

    directives: list[SpecDirective] | None = None
    mission_log_entry: MissionLogEntry | None = None
    error_entry: ErrorEntry | None = None
    active_task: str | None = None


class ClaudeMdResponse(BaseModel):
    """Response containing rendered CLAUDE.md."""

    content: str
    version: int


class GeminiMdResponse(BaseModel):
    """Response containing rendered GEMINI.md."""

    content: str
    version: int


@router.get("/{project_id}", response_model=LivingSpec)
async def get_spec(
    project_id: str,
    session: Annotated[AsyncSession, Depends(get_session)],
) -> LivingSpec:
    """Get the living specification for a project."""
    result = await session.execute(
        select(Project).where(Project.id == project_id)
    )
    project = result.scalar_one_or_none()

    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get latest spec artifact
    spec_result = await session.execute(
        select(Artifact)
        .where(Artifact.project_id == project_id)
        .where(Artifact.artifact_type == ArtifactType.SPEC)
        .order_by(Artifact.version.desc())
        .limit(1)
    )
    spec_artifact = spec_result.scalar_one_or_none()

    # Build spec from project and artifact
    return LivingSpec(
        project_id=project.id,
        version=spec_artifact.version if spec_artifact else 1,
        status=project.status.value,
        directives=[
            SpecDirective(id="1", content="Use TypeScript for all code"),
            SpecDirective(id="2", content="Test with Jest"),
            SpecDirective(id="3", content="No external CSS libraries"),
        ],
        tech_stack=project.tech_stack or {},
        current_phase=project.status.value,
        active_task=None,
        mission_log=[],
        error_registry=[],
    )


@router.patch("/{project_id}", response_model=LivingSpec)
async def update_spec(
    project_id: str,
    update: SpecUpdate,
    session: Annotated[AsyncSession, Depends(get_session)],
) -> LivingSpec:
    """Update the living specification."""
    result = await session.execute(
        select(Project).where(Project.id == project_id)
    )
    project = result.scalar_one_or_none()

    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Update would be applied here
    # For now, return current spec
    return await get_spec(project_id, session)


@router.get("/{project_id}/claude.md", response_model=ClaudeMdResponse)
async def get_claude_md(
    project_id: str,
    session: Annotated[AsyncSession, Depends(get_session)],
) -> ClaudeMdResponse:
    """Get the rendered CLAUDE.md for a project."""
    spec = await get_spec(project_id, session)

    # Render template
    content = f"""# {project_id} - Living Specification

## Directives

{chr(10).join(f'- {d.content}' for d in spec.directives)}

## Current Phase

**Phase:** {spec.current_phase}

## Tech Stack

```json
{spec.tech_stack}
```

---
*Auto-generated by Autonomous Enterprise*
"""

    return ClaudeMdResponse(content=content, version=spec.version)


@router.get("/{project_id}/gemini.md", response_model=GeminiMdResponse)
async def get_gemini_md(
    project_id: str,
    session: Annotated[AsyncSession, Depends(get_session)],
) -> GeminiMdResponse:
    """Get the rendered GEMINI.md for a project."""
    spec = await get_spec(project_id, session)

    # Render template
    content = f"""# {project_id} - Gemini Context

## Quick Reference

| Key | Value |
|-----|-------|
| Project | {project_id} |
| Phase | {spec.current_phase} |

## Active Directives

{chr(10).join(f'{i+1}. {d.content}' for i, d in enumerate(spec.directives))}

---
*Auto-managed by Autonomous Enterprise*
"""

    return GeminiMdResponse(content=content, version=spec.version)
